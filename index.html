<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Texture Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI Panel */
        #ui-container {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            background: rgba(15, 15, 20, 0.8); backdrop-filter: blur(8px);
            padding: 20px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1);
            color: white; width: 320px;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        #ui-container.hidden { opacity: 0; pointer-events: none; transform: translateX(-20px); }

        h1 { margin: 0 0 10px 0; font-size: 18px; color: #00ffff; }
        .info { font-size: 13px; color: #ccc; margin-bottom: 5px; line-height: 1.5; }
        .gesture-list { font-size: 12px; color: #aaa; margin-top: 10px; padding-left: 15px; }
        .gesture-list li { margin-bottom: 4px; }
        
        #status {
            margin-top: 15px; padding: 8px; border-radius: 4px;
            background: rgba(255, 165, 0, 0.2); color: #ffb74d;
            font-size: 12px; font-weight: bold; text-align: center;
        }
        #status.active { background: rgba(0, 255, 127, 0.2); color: #69f0ae; }
        
        /* Camera Preview */
        .input_video { display: none; }
        #camera-preview {
            position: absolute; bottom: 20px; right: 20px; 
            width: 160px; height: 120px; z-index: 10; border-radius: 8px; 
            border: 2px solid rgba(255,255,255,0.2);
            transform: scaleX(-1); background: #000; opacity: 0.8;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        
        .controls { margin-top: 15px; }
        .control-group { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; font-size: 13px; }
        input[type="color"] { border: none; width: 40px; height: 25px; background: none; cursor: pointer; }
        
        #toggle-ui-btn {
            position: absolute; top: 20px; left: 20px; z-index: 20;
            background: rgba(0, 255, 255, 0.2); border: 1px solid #00ffff;
            color: #00ffff; border-radius: 50%; width: 40px; height: 40px;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            font-size: 20px; transition: all 0.3s;
        }
        #toggle-ui-btn:hover { background: rgba(0, 255, 255, 0.4); box-shadow: 0 0 10px #00ffff; }
        #ui-container:not(.hidden) + #toggle-ui-btn {
            top: 25px; left: 300px; width: 30px; height: 30px; font-size: 14px; background: transparent; border: none; color: #666;
        }
        #ui-container:not(.hidden) + #toggle-ui-btn:hover { color: white; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <video class="input_video"></video>
    
    <div id="ui-container">
        <h1>Multi-Texture Particles</h1>
        <div class="info">Gi∆° tay ƒëi·ªÅu khi·ªÉn:</div>
        <ul class="gesture-list">
            <li>‚úä 0 ng√≥n: H√¨nh c·∫ßu (Reset)</li>
            <li>‚òùÔ∏è 1 ng√≥n: "Hello"</li>
            <li>‚úåÔ∏è 2 ng√≥n: "24/12/2025"</li>
            <li>üëå 3 ng√≥n: "Happy birthday"</li>
            <li>üññ 4 ng√≥n: "hwamin"</li>
            <li style="color: #ff00ff; font-weight: bold;">üñê 5 ng√≥n: BUNG V≈® TR·ª§ (Tr·ªôn T·∫•t C·∫£ ·∫¢nh) ‚ú®</li>
        </ul>
        
        <div class="controls">
            <div class="control-group">
                <label>M√†u h·∫°t (ch·∫ø ƒë·ªô th∆∞·ªùng):</label>
                <input type="color" id="colorPicker" value="#00ffff">
            </div>
            <div style="font-size: 10px; color: #888; margin-top: 5px;">*5 ng√≥n s·∫Ω d√πng ·∫£nh g·ªëc, kh√¥ng d√πng m√†u n√†y</div>
        </div>

        <div id="status">ƒêang t·∫£i t√†i nguy√™n...</div>
        <div id="debug-fingers" style="font-size: 11px; margin-top: 5px; color: #888;">S·ªë ng√≥n: 0</div>
    </div>

    <button id="toggle-ui-btn" title="·∫®n/Hi·ªán B·∫£ng ƒëi·ªÅu khi·ªÉn">üëÅÔ∏è</button>

    <div id="canvas-container"></div>
    <canvas id="camera-preview" width="160" height="120"></canvas>

    <script>
        // ==========================================
        // 1. C·∫§U H√åNH ·∫¢NH (DANH S√ÅCH ·∫¢NH)
        // ==========================================
        const imageList = [
            './anh1.jpg',
            './anh2.jpg',
            './anh3.jpg',
            './anh4.jpg',
            './anh5.jpg', 
            './anh6.jpg',
            './anh7.jpg',
            './anh8.jpg',
            './anh9.jpg',
            './anh10.jpg',
        ];

        // ==========================================
        // 2. KH·ªûI T·∫†O C∆† B·∫¢N
        // ==========================================
        const uiContainer = document.getElementById('ui-container');
        const toggleBtn = document.getElementById('toggle-ui-btn');
        const statusDiv = document.getElementById('status');
        const debugDiv = document.getElementById('debug-fingers');

        toggleBtn.addEventListener('click', () => {
            uiContainer.classList.toggle('hidden');
            if (uiContainer.classList.contains('hidden')) {
                toggleBtn.innerText = 'üëÅÔ∏è'; toggleBtn.style.left = '20px'; toggleBtn.style.top = '20px';
            } else { toggleBtn.innerText = '‚úñ'; }
        });

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
        camera.position.z = 400; 

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // T·∫°o Texture m·∫∑c ƒë·ªãnh (h√¨nh tr√≤n)
        function createCircleTexture() {
            const c = document.createElement('canvas'); c.width = 32; c.height = 32;
            const ctx = c.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.5, 'rgba(255,255,255,0.5)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
            const tex = new THREE.Texture(c); tex.needsUpdate = true; return tex;
        }
        const defaultTexture = createCircleTexture();

        // ==========================================
        // 3. X·ª¨ L√ù ƒêA H·ªÜ TH·ªêNG H·∫†T (MULTI-SYSTEM)
        // ==========================================
        
        const totalParticles = 8100; // S·ªë l∆∞·ª£ng t·ªïng (n√™n chia h·∫øt cho s·ªë ·∫£nh n·∫øu c√≥ th·ªÉ)
        const loadedUserTextures = []; 
        const particleGroups = []; // M·∫£ng ch·ª©a c√°c nh√≥m h·∫°t con
        
        // M·∫£ng to√†n c·ª•c l∆∞u v·ªã tr√≠ ƒë·ªÉ t√≠nh to√°n v·∫≠t l√Ω chung
        const globalCurrentPositions = new Float32Array(totalParticles * 3);
        const globalTargetPositions = new Float32Array(totalParticles * 3);

        // H√†m t·∫£i ·∫£nh Promise
        function loadTextureAsync(url) {
            return new Promise((resolve, reject) => {
                new THREE.TextureLoader().load(url, 
                    (tex) => resolve(tex),
                    undefined,
                    (err) => { console.warn("L·ªói t·∫£i ·∫£nh:", url); resolve(null); } // L·ªói th√¨ tr·∫£ v·ªÅ null ƒë·ªÉ kh√¥ng crash
                );
            });
        }

        async function initParticles() {
            // T·∫£i t·∫•t c·∫£ ·∫£nh tr∆∞·ªõc
            const textures = await Promise.all(imageList.map(url => loadTextureAsync(url)));
            // L·ªçc b·ªè ·∫£nh l·ªói
            textures.forEach(t => { if(t) loadedUserTextures.push(t); });

            // N·∫øu kh√¥ng c√≥ ·∫£nh n√†o t·∫£i ƒë∆∞·ª£c, d√πng default
            if (loadedUserTextures.length === 0) loadedUserTextures.push(defaultTexture);

            const groupCount = loadedUserTextures.length;
            const particlesPerGroup = Math.ceil(totalParticles / groupCount);

            // T·∫°o c√°c nh√≥m h·∫°t
            for (let g = 0; g < groupCount; g++) {
                const geometry = new THREE.BufferGeometry();
                const posArray = new Float32Array(particlesPerGroup * 3);
                
                // Kh·ªüi t·∫°o v·ªã tr√≠ ng·∫´u nhi√™n
                for(let i=0; i<particlesPerGroup * 3; i++) {
                    posArray[i] = (Math.random() - 0.5) * 800;
                }
                
                // Map v·ªã tr√≠ c·ª•c b·ªô v√†o m·∫£ng to√†n c·ª•c ƒë·ªÉ qu·∫£n l√Ω
                const startIndex = g * particlesPerGroup;
                for(let i=0; i<particlesPerGroup; i++) {
                    const globalIdx = (startIndex + i) * 3;
                    const localIdx = i * 3;
                    globalCurrentPositions[globalIdx] = posArray[localIdx];
                    globalCurrentPositions[globalIdx+1] = posArray[localIdx+1];
                    globalCurrentPositions[globalIdx+2] = posArray[localIdx+2];
                    
                    // Kh·ªüi t·∫°o target b·∫±ng current
                    globalTargetPositions[globalIdx] = posArray[localIdx];
                    globalTargetPositions[globalIdx+1] = posArray[localIdx+1];
                    globalTargetPositions[globalIdx+2] = posArray[localIdx+2];
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));

                // Material ri√™ng cho nh√≥m n√†y (ƒë·ªÉ ch·ª©a texture ri√™ng)
                const material = new THREE.PointsMaterial({
                    size: 3,
                    map: defaultTexture, // M·∫∑c ƒë·ªãnh d√πng h√¨nh tr√≤n
                    color: 0x00ffff,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                const points = new THREE.Points(geometry, material);
                
                // L∆∞u metadata ƒë·ªÉ d√πng sau n√†y
                particleGroups.push({
                    mesh: points,
                    originalTexture: loadedUserTextures[g], // L∆∞u texture ·∫£nh g·ªëc c·ªßa nh√≥m n√†y
                    startIndex: startIndex,
                    count: particlesPerGroup
                });

                scene.add(points);
            }
            
            statusDiv.innerText = "S·∫µn s√†ng! H√£y b·∫≠t Camera.";
            updateMorphTarget('sphere'); // T·∫°o h√¨nh c·∫ßu ban ƒë·∫ßu
        }

        initParticles();

        // ==========================================
        // 4. C√ÅC H√ÄM T·∫†O H√åNH D√ÅNG (SHAPE GENERATORS)
        // ==========================================

        function createTextTarget(text) {
            const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
            const fontSize = 100; const fontFamily = 'Arial, sans-serif';
            ctx.font = `bold ${fontSize}px ${fontFamily}`;
            const textMetrics = ctx.measureText(text);
            const width = Math.ceil(textMetrics.width); const height = fontSize * 1.5;
            canvas.width = width; canvas.height = height;
            ctx.font = `bold ${fontSize}px ${fontFamily}`;
            ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, width / 2, height / 2);
            
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const validPoints = []; const step = 2; 
            for (let y = 0; y < height; y += step) {
                for (let x = 0; x < width; x += step) {
                    if (data[((y * width + x) * 4) + 3] > 128) {
                        validPoints.push({ x: (x - width / 2), y: -(y - height / 2) });
                    }
                }
            }
            return { points: validPoints };
        }

        function createSphereTarget() {
            const points = []; const radius = 100;
            for(let i=0; i<totalParticles; i++){
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                points.push({
                    x: radius * Math.sin(phi) * Math.cos(theta),
                    y: radius * Math.sin(phi) * Math.sin(theta),
                    z: radius * Math.cos(phi)
                });
            }
            return points;
        }

        // ==========================================
        // 5. C·∫¨P NH·∫¨T TR·∫†NG TH√ÅI (UPDATE LOGIC)
        // ==========================================

        function updateMorphTarget(shapeType, textString = "") {
            let points = []; 
            let scaleFactor = 1.0;
            const isUniverseMode = (shapeType === 'universe');

            // C·∫≠p nh·∫≠t Material cho T·∫§T C·∫¢ c√°c nh√≥m
            particleGroups.forEach(group => {
                if (isUniverseMode) {
                    // Ch·∫ø ƒë·ªô 5 ng√≥n: D√πng ·∫£nh g·ªëc c·ªßa nh√≥m ƒë√≥
                    group.mesh.material.map = group.originalTexture;
                    group.mesh.material.size = 15; // To h∆°n ƒë·ªÉ nh√¨n r√µ ·∫£nh
                    group.mesh.material.color.setHex(0xffffff); // M√†u tr·∫Øng ƒë·ªÉ hi·ªÉn th·ªã ƒë√∫ng m√†u ·∫£nh
                    group.mesh.material.opacity = 0.9;
                } else {
                    // Ch·∫ø ƒë·ªô th∆∞·ªùng: D√πng h√¨nh tr√≤n v√† m√†u t·ª´ color picker
                    group.mesh.material.map = defaultTexture;
                    group.mesh.material.size = 3;
                    group.mesh.material.color.set(document.getElementById('colorPicker').value);
                    group.mesh.material.opacity = 1.0;
                }
                group.mesh.material.needsUpdate = true;
            });

            // T√≠nh to√°n v·ªã tr√≠ ƒë√≠ch
            if (isUniverseMode) {
                // Random v·ªã tr√≠ lung tung
                for(let i=0; i<totalParticles; i++){
                    globalTargetPositions[i*3] = (Math.random() - 0.5) * 1500;
                    globalTargetPositions[i*3+1] = (Math.random() - 0.5) * 1000;
                    globalTargetPositions[i*3+2] = (Math.random() - 0.5) * 1000;
                }
            } else {
                if (shapeType === 'sphere') {
                    points = createSphereTarget();
                } else if (shapeType === 'text') {
                    const data = createTextTarget(textString);
                    points = data.points;
                    if (textString.length > 8) {
                        scaleFactor = 12 / textString.length; 
                        scaleFactor = Math.max(0.4, Math.min(scaleFactor, 1.5));
                    } else { scaleFactor = 1.2; }
                }

                // G√°n v·ªã tr√≠ ƒë√≠ch
                for (let i = 0; i < totalParticles; i++) {
                    const i3 = i * 3;
                    if (i < points.length) {
                        globalTargetPositions[i3] = points[i].x * scaleFactor;
                        globalTargetPositions[i3+1] = points[i].y * scaleFactor;
                        globalTargetPositions[i3+2] = (points[i].z || 0) * scaleFactor;
                    } else {
                        // H·∫°t d∆∞ th·ª´a th√¨ bay ra xa m·ªù nh·∫°t ho·∫∑c v·ªÅ t√¢m
                        globalTargetPositions[i3] = (Math.random()-0.5) * 500;
                        globalTargetPositions[i3+1] = (Math.random()-0.5) * 500;
                        globalTargetPositions[i3+2] = (Math.random()-0.5) * 500;
                    }
                }
            }
        }

        // ==========================================
        // 6. MEDIAPIPE & CAMERA
        // ==========================================
        let lastFingerCount = -1;

        function countExtendedFingers(landmarks) {
            let count = 0;
            const thumbTip = landmarks[4]; const thumbIP = landmarks[3]; const p17 = landmarks[17];
            if (Math.sqrt(Math.pow(thumbTip.x-p17.x, 2) + Math.pow(thumbTip.y-p17.y, 2)) > 
                Math.sqrt(Math.pow(thumbIP.x-p17.x, 2) + Math.pow(thumbIP.y-p17.y, 2))) count++;
            
            const tips = [8, 12, 16, 20]; const pips = [6, 10, 14, 18];
            for (let i = 0; i < 4; i++) {
                if (landmarks[tips[i]].y < landmarks[pips[i]].y) count++;
            }
            return count;
        }

        function onResults(results) {
            const canvas = document.getElementById('camera-preview');
            const canvasCtx = canvas.getContext('2d');
            canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
            canvasCtx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                statusDiv.innerText = "ƒê√£ nh·∫≠n di·ªán tay!";
                statusDiv.classList.add('active');
                const fingers = countExtendedFingers(results.multiHandLandmarks[0]);
                debugDiv.innerText = `S·ªë ng√≥n: ${fingers}`;

                if (fingers !== lastFingerCount) {
                    lastFingerCount = fingers;
                    switch (fingers) {
                        case 0: updateMorphTarget('sphere'); break;
                        case 1: updateMorphTarget('text', "Hello"); break;
                        case 2: updateMorphTarget('text', "24/12/2025"); break;
                        case 3: updateMorphTarget('text', "Happy Birthday"); break;
                        case 4: updateMorphTarget('text', "Hwamin"); break;
                        case 5: updateMorphTarget('universe'); break; 
                        default: updateMorphTarget('sphere');
                    }
                }
            } else {
                statusDiv.innerText = "ƒêang ch·ªù b√†n tay...";
                statusDiv.classList.remove('active');
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        hands.onResults(onResults);

        const videoElement = document.getElementsByClassName('input_video')[0];
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraUtils.start();

        // ==========================================
        // 7. ANIMATION LOOP
        // ==========================================
        
        // S·ª± ki·ªán ƒë·ªïi m√†u color picker
        document.getElementById('colorPicker').addEventListener('input', (e) => {
            if (lastFingerCount !== 5) {
                particleGroups.forEach(g => g.mesh.material.color.set(e.target.value));
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            const lerpSpeed = 0.08; 

            // 1. T√≠nh to√°n v·ªã tr√≠ v·∫≠t l√Ω tr√™n m·∫£ng to√†n c·ª•c (Global Array)
            for(let i=0; i<totalParticles; i++) {
                const i3 = i * 3;
                globalCurrentPositions[i3]   += (globalTargetPositions[i3]   - globalCurrentPositions[i3])   * lerpSpeed;
                globalCurrentPositions[i3+1] += (globalTargetPositions[i3+1] - globalCurrentPositions[i3+1]) * lerpSpeed;
                globalCurrentPositions[i3+2] += (globalTargetPositions[i3+2] - globalCurrentPositions[i3+2]) * lerpSpeed;

                // Hi·ªáu ·ª©ng lung linh nh·∫π
                if (Math.abs(globalTargetPositions[i3] - globalCurrentPositions[i3]) < 20) {
                    globalCurrentPositions[i3] += Math.sin(time * 3 + i) * 0.2;
                    globalCurrentPositions[i3+1] += Math.cos(time * 2 + i) * 0.2;
                }
            }

            // 2. ƒê·ªìng b·ªô v·ªã tr√≠ t·ª´ m·∫£ng to√†n c·ª•c v·ªÅ t·ª´ng nh√≥m h·∫°t (Sub-systems)
            particleGroups.forEach(group => {
                const positions = group.mesh.geometry.attributes.position.array;
                const start = group.startIndex;
                const count = group.count;

                for(let j=0; j<count; j++) {
                    const globalIdx = (start + j) * 3;
                    const localIdx = j * 3;
                    positions[localIdx]   = globalCurrentPositions[globalIdx];
                    positions[localIdx+1] = globalCurrentPositions[globalIdx+1];
                    positions[localIdx+2] = globalCurrentPositions[globalIdx+2];
                }
                group.mesh.geometry.attributes.position.needsUpdate = true;

                // Xoay nh·∫π h·ªá th·ªëng
                if (lastFingerCount === 5) {
                    group.mesh.rotation.y += 0.001;
                    group.mesh.rotation.x += 0.0005;
                } else if (lastFingerCount === 0 || lastFingerCount === -1) {
                    group.mesh.rotation.y = time * 0.1;
                } else {
                    group.mesh.rotation.y += (0 - group.mesh.rotation.y) * 0.05;
                    group.mesh.rotation.x += (0 - group.mesh.rotation.x) * 0.05;
                }
            });

            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>